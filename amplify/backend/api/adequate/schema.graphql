# Deal
type Deal @model
    @key(name: "byYearMonthDate", fields: ["dealYear", "monthDay"], queryField: "dealsForPeriod")
    @auth(rules: [
      { allow: private, provider: iam },
      { allow: public, operations: [ read ], provider: iam }
    ])
{
    id: ID!
    dealID: ID!
    dealYear: String!
    monthDay: String!
    title: String!
    features: String!
    specifications: String!
    url: AWSURL!
    # Both `createdAt` and `updatedAt` are supposed to be automatic now, but if we do not list it explicitly,
    # we cannot change it manually (to make it match `topic.createdAt`, for instance)
    # TODO: use `startDate` instead of / in addition to `createdAt`?
    createdAt: AWSDateTime!
    endDate: AWSDateTime
    soldOutAt: AWSDateTime
    items: [Item!]!
    modelNumbers: [String!]
    photos: [AWSURL!]!
    story: Story
    topic: Topic
    theme: Theme!
    purchaseQuantity: PurchaseQuantity
    # TODO: should we require `launches` and make lambda add it if meh.com response doesn't have it?
    # TODO: do we need to make `Launch` nullable so we can overwrite current deal w/o `launches` with a new deal that also lacks them?
    launches: [Launch!]
    launchStatus: LaunchStatus!
}

type Item {
    id: ID!
    attributes: [ItemAttribute]!
    condition: String!
    # price: Int!
    price: Float!
    photo: AWSURL!
}

type ItemAttribute {
    key: String!
    value: String!
}

type Launch {
    soldOutAt: AWSDateTime
}

type PurchaseQuantity {
    maximumLimit: Int!
    minimumLimit: Int!
}

type Story {
    title: String!
    body: String!
}

type Theme {
    accentColor: String!
    backgroundColor: String!
    backgroundImage: AWSURL
    foreground: ThemeForeground!
}

enum ThemeForeground {
    dark
    light
}

type Topic {
    id: ID!
    commentCount: Int!
    createdAt: AWSDateTime!
    replyCount: Int!
    url: AWSURL!
    voteCount: Int!
}

# TODO: add `mehrathon` status
enum LaunchStatus {
    launch
    launchSoldOut
    relaunch
    relaunchSoldOut
    reserve
    soldOut
    expired
}

# Custom Mutation and associated types
input CreateDealInput {
  id: ID
  dealID: ID!
  # dealYear: String!
  # monthDay: String!
  title: String!
  features: String!
  specifications: String!
  url: AWSURL!
  createdAt: AWSDateTime
  endDate: AWSDateTime
  soldOutAt: AWSDateTime
  items: [ItemInput!]!
  modelNumbers: [String!]
  photos: [AWSURL!]!
  story: StoryInput
  topic: TopicInput
  theme: ThemeInput!
  purchaseQuantity: PurchaseQuantityInput
  launches: [LaunchInput!]
  launchStatus: LaunchStatus!
  _version: Int
}

# TODO: add `UpdateDealInput` w/o `dealYear` and `monthDay` fields?
# input UpdateDealInput {
#   id: ID!
#   dealID: ID
#   # dealYear: String
#   # monthDay: String
#   title: String
#   features: String
#   specifications: String
#   url: AWSURL
#   createdAt: AWSDateTime
#   endDate: AWSDateTime
#   soldOutAt: AWSDateTime
#   items: [ItemInput!]
#   modelNumbers: [String!]
#   photos: [AWSURL!]
#   story: StoryInput
#   topic: TopicInput
#   theme: ThemeInput
#   purchaseQuantity: PurchaseQuantityInput
#   launches: [LaunchInput!]
#   launchStatus: LaunchStatus
#   _version: Int
# }

input ItemInput {
  id: ID!
  attributes: [ItemAttributeInput]!
  condition: String!
  # price: Int!
  price: Float!
  photo: AWSURL!
}

input ItemAttributeInput {
  key: String!
  value: String!
}

input StoryInput {
  title: String!
  body: String!
}

input TopicInput {
  id: ID!
  commentCount: Int!
  createdAt: AWSDateTime!
  replyCount: Int!
  url: AWSURL!
  voteCount: Int!
}

input ThemeInput {
  accentColor: String!
  backgroundColor: String!
  backgroundImage: AWSURL
  foreground: ThemeForeground!
}

input PurchaseQuantityInput {
  maximumLimit: Int!
  minimumLimit: Int!
}

input LaunchInput {
  soldOutAt: AWSDateTime
}

# Custom Queries - Supporting Types
# TODO: should we return a special result or just return `Deal`?
type DealHistoryResult {
    id: ID!
    title: String!
    createdAt: AWSDateTime!
    dealYear: String!
    monthDay: String!
    items: [Item!]!
    # modelNumbers: [String!]
    photos: [AWSURL!]!
    # story: Story
    theme: Theme!
}

type DealHistoryConnection {
    items: [DealHistoryResult]
    nextToken: String
    startedAt: AWSTimestamp
}

# We can't rely on the autogenerated types like `ModelIDInput`,
# so we have to duplicate them here
input CustomIDFilterInput {
    ne: ID
    eq: ID
    le: ID
    lt: ID
    ge: ID
    gt: ID
    contains: ID
    notContains: ID
    between: [ID]
    beginsWith: ID
}

input CustomStringFilterInput {
    ne: String
    eq: String
    le: String
    lt: String
    ge: String
    gt: String
    contains: String
    notContains: String
    between: [String]
    beginsWith: String
}

input CustomLaunchStatusInput {
    eq: LaunchStatus
    ne: LaunchStatus
}

enum CustomSortDirection {
    ASC
    DESC
}

input DealHistoryFilterInput {
    id: CustomIDFilterInput
    dealID: CustomIDFilterInput
    dealYear: CustomStringFilterInput
    monthDay: CustomStringFilterInput
    title: CustomStringFilterInput
    features: CustomStringFilterInput
    specifications: CustomStringFilterInput
    url: CustomStringFilterInput
    createdAt: CustomStringFilterInput
    endDate: CustomStringFilterInput
    soldOutAt: CustomStringFilterInput
    modelNumbers: CustomStringFilterInput
    photos: CustomStringFilterInput
    launchStatus: CustomLaunchStatusInput
    and: [DealHistoryFilterInput]
    or: [DealHistoryFilterInput]
    not: DealHistoryFilterInput
}

# Queries
# Add `sortDirection: CustomSortDirection`?
type Query {
  dealHistory(filter: DealHistoryFilterInput, limit: Int, nextToken: String): DealHistoryConnection
    @aws_iam
    # @auth(rules: [ { allow: public, provider: iam } ])
}
